h <- function(x, y = NULL, d = 3L) {
z <- cbind(x, d)
if(!is.null(y))
z <- z + y
else
z <- z + f
g <- x + y / z
if(d == 3L)
return(g)
g <- g + 10
g
}
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
z <- 10
f(3)
View(h)
help(read.csv)
mydata=read.csv("001.csv")
getwd()
mydata=read.csv("001.csv")
mydata=read.csv(001.csv)
data<-read.tabke("001.csv")
data<-read.table("001.csv")
getwd()
read.csv("001.csv")
read.csv("001.csv")
read.csv("331.csv")
read.csv("specdata")
pollutantmean<-function(directory,pollutant,id=1:332)
source("pollutantmean.R")
pollutantmean("specdata","sulfate",1:10)
pollutantmean<-function(directory,pollutant,id-1:332{)
pollutantmean<-function(directory,pollutant,id-1:332{}
pollutantmean<-function(directory,pollutant,id-1:332){}
pollutantmean<-function(directory,pollutant,id=1:332){}
complete<-function(directory,id=1:332)
corr<-function(directory,threshold=0)
pollutantmean("specdata","sulfate",1:10)
source("pollutantmean.R")
pollutantmean <- function(directory, pollutant, id = 1:332) {
files_full <- list.files(directory, full.names = TRUE)
dat <- data.frame()
for (i in id) {
dat <- rbind(dat, read.csv(files_full[i]))
}
mean(dat[, pollutant], na.rm = TRUE)
}
pollutantmean <- function(directory, pollutant, id = 1:332) {
setwd(file.path(getwd(), directory)) ## setting the directory
total = 0                            ## the sum of all observed values of pollutant (either sulfate or nitrate)
observations = 0                     ## the total number of observed values of pollutant (either sulfate or nitrate)
#Looping thru the directory's files specified in the 'id' argument
for (i in id)
{
## Due to the format of the filename, i.e 001, 010  instead of 1, 10. I became aware that the following method works but not efficient,
## but at the time of the completion of this assignment, it was the only way I knew how to do it.
if (i <10) {
data <- read.csv(paste("0","0", as.character(i), ".csv", sep=""),  ## for example, if 'id' =7, we get 007.csv
header = T,
na.strings=c("NA","NaN", " "))
}
else if (i>=10 & i<100) {
data <- read.csv(paste("0", as.character(i), ".csv", sep=""),  ## for example, if 'id' = 17, we get 017.csv
header = T,
na.strings=c("NA","NaN", " ")
)
}
else       {
data <- read.csv(paste(as.character(i), ".csv", sep=""),     ## Normal
header = T,
na.strings=c("NA","NaN", " ")
)
}
## getting rid of all the "NA" values and, consequently, all the non-complete ovservations (the ones with at least one NA in row)
data = na.omit(data)
##  cumulative addition of the complete observations
observations = observations + nrow(data)
## depending the poluttant ( sulfate or nitrate), we aggregate the observed values
if (pollutant == "sulfate") {total = total + sum(data$sulfate)}
else {total = total + sum(data$nitrate)}
}
## reset directory path
setwd("..")
## returning the mean of the pollutant values
return (total/observations)
}
pollutantmean("specdata", "sulfate", 1:10)
getwd()
pollutantmean("specdata", "sulfate", 1:10)
pollutantmean <- function(directory, pollutant, id = 1:332) {
files_full <- list.files(directory, full.names = TRUE)
dat <- data.frame()
for (i in id) {
dat <- rbind(dat, read.csv(files_full[i]))
}
mean(dat[, pollutant], na.rm = TRUE)
}
source("pollutantmean.R")
pollutantmean("specdata", "sulfate", 1:10)
pollutantmean <- function(directory, pollutant, id = 1:332) {
files_full <- list.files(directory, full.names = TRUE)
dat <- data.frame()
for (i in id) {
dat <- rbind(dat, read.csv(files_full[i]))
}
mean(dat[, pollutant], na.rm = TRUE)
}
pollutantmean("specdata", "sulfate", 1:10)
pollutantmean("specdata", "nitrate", 70:72)
pollutantmean("specdata", "sulfate", 34)
pollutantmean("specdata", "nitrate", 70:72)
pollutantmean("specdata", "nitrate")
cc <- complete("specdata", c(6, 10, 20, 34, 100, 200, 310))
print(cc$nobs)
complete <- function(directory, id = 1:332) {
files_full <- list.files(directory, full.names = TRUE)
dat <- data.frame()
for (i in id) {
moni_i <- read.csv(files_full[i])
nobs <- sum(complete.cases(moni_i))
tmp <- data.frame(i, nobs)
dat <- rbind(dat, tmp)
}
colnames(dat) <- c("id", "nobs")
dat
}
set.seed(42)
cc <- complete("specdata", 332:1)
use <- sample(332, 10)
print(cc[use, "nobs"])
cc <- complete("specdata", 54)
print(cc$nobs)
cc <- complete("specdata", c(6, 10, 20, 34, 100, 200, 310))
print(cc$nobs)
cr <- corr("specdata")
cr <- sort(cr)
set.seed(868)
out <- round(cr[sample(length(cr), 5)], 4)
print(out)
pollutantmean("specdata", "nitrate")
orr <- function(directory, threshold = 0) {
files_full <- list.files(directory, full.names = TRUE)
dat <- vector(mode = "numeric", length = 0)
for (i in 1:length(files_full)) {
moni_i <- read.csv(files_full[i])
csum <- sum((!is.na(moni_i$sulfate)) & (!is.na(moni_i$nitrate)))
if (csum > threshold) {
tmp <- moni_i[which(!is.na(moni_i$sulfate)), ]
submoni_i <- tmp[which(!is.na(tmp$nitrate)), ]
dat <- c(dat, cor(submoni_i$sulfate, submoni_i$nitrate))
}
}
dat
}
cr <- corr("specdata", 129)
cr <- sort(cr)
n <- length(cr)
set.seed(197)
out <- c(n, round(cr[sample(n, 5)], 4))
print(out)
cr <- corr("specdata", 129)
cr <- sort(cr)
n <- length(cr)
set.seed(197)
out <- c(n, round(cr[sample(n, 5)], 4))
print(out)
cr <- corr("specdata", 2000)
n <- length(cr)
cr <- corr("specdata", 1000)
cr <- sort(cr)
print(c(n, round(cr, 4)))
corr <- function(directory, threshold = 0) {
files_full <- list.files(directory, full.names = TRUE)
dat <- vector(mode = "numeric", length = 0)
for (i in 1:length(files_full)) {
moni_i <- read.csv(files_full[i])
csum <- sum((!is.na(moni_i$sulfate)) & (!is.na(moni_i$nitrate)))
if (csum > threshold) {
tmp <- moni_i[which(!is.na(moni_i$sulfate)), ]
submoni_i <- tmp[which(!is.na(tmp$nitrate)), ]
dat <- c(dat, cor(submoni_i$sulfate, submoni_i$nitrate))
}
}
dat
}
cr <- corr("specdata")
cr <- sort(cr)
set.seed(868)
out <- round(cr[sample(length(cr), 5)], 4)
print(out)
cr <- corr("specdata", 129)
cr <- sort(cr)
n <- length(cr)
set.seed(197)
out <- c(n, round(cr[sample(n, 5)], 4))
print(out)
cr <- corr("specdata", 2000)
n <- length(cr)
cr <- corr("specdata", 1000)
cr <- sort(cr)
print(c(n, round(cr, 4)))
library(datasets)
data(iris)
?iris
lapply (x,SepalLength)
lapply(SepalLength,virginica)
lapply(Sepal.Length,mean)
lapply(x,mean)
lapply(virginica,mean)
library(datasets)
data(iris)
?iris
data(iris)
head(iris)
mean(iris$Sepal.Length)
apply(iris,1,mean)
colMeans(iris)
apply(iris,2,mean)
apply(iris[,1:4],1)
apply(iris[,1:4],2,mean)
library(datasets)
data(mtcars)
?mtcars
data(mtcars)
head(mtcars)
apply(iris,Sepal.Length,mean)
apply(iris,1,mean)
colSums=apply(iris,2,mean)
apply(mtcars, 2, mean)
lapply(mtcars, mean)
lapply(iris,mean)
tapply(mtcars$mpg, mtcars$cyl, mean)
abs(mean(mtcars[mtcarscyl==4,]hp) - mean(mtcars[mtcarscyl==8,]hp))
abs(mean(mtcars[mtcarscyl==4,]hp) - mean(mtcars[mtcarscyl==8,]hp))
absolute(mean(mtcars[mtcarscyl==4,]hp) - mean(mtcars[mtcarscyl==8,]hp))
debug(ls)
ls
x <- tapply(mtcars$hp, mtcars$cyl, mean)
x['8'] - x['4']
tapply(mtcars$hp, mtcars$cyl, mean)
> x['8'] - x['4']
tapply(mtcars$hp, mtcars$cyl, mean)
x['8'] - x['4']
data(iris)
head(iris)
$git clone https://github.com/yapnorman/ProgrammingAssignment2.git
git clone https://github.com/yapnorman/ProgrammingAssignment2.git
$ git clone https://github.com/yapnorman/ProgrammingAssignment2.git
git clone https://github.com/yapnorman/ProgrammingAssignment2.git
source("ProgrammingAssignment2/cachematrix.R")
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get()
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function() inv
list(set = set,
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
source("ProgrammingAssignment2/cachematrix.R")
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get()
my_matrix$getInverse()
cacheSolve(my_matrix)
cacheSolve(my_matrix)
View(cacheSolve)
View(cacheSolve)
View(makeCacheMatrix)
View(cacheSolve)
View(makeCacheMatrix)
View(cacheSolve)
